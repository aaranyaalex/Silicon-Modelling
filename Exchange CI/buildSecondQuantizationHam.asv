function sparams = buildSecondQuantizationHam(sparams, spinSubSystems)
%BUILDSECONDQUANTIZATIONHAM Summary of this function goes here
%   Detailed explanation goes here
    nSOstates = 2*sparams.nSingleOrbitals;
    if sparams.numElectrons > nSOstates
        error('Not enough states for the desired number of electrons.\n');
    elseif sparams.numElectrons < 2
        error('Need at least two electrons to calculate J.\n');
    end
    
    % Get all possible state configurations
    stateConfigurations = nchoosek(1:nSOstates,sparams.numElectrons);
    [nStates,~] = size(stateConfigurations);
    
    % Now arrange the states into our format
    sparams.basisVectors = zeros(nStates,2*sparams.numElectrons);
    for ii = 1:nStates
        currentConfig = stateConfigurations(ii,:);
        for jj = 1:sparams.numElectrons
            if mod(currentConfig(jj),2) == 1   
                sparams.basisVectors(ii,jj) = (currentConfig(jj) + 1)/2;
                sparams.basisVectors(ii,jj + sparams.numElectrons) = 0;
            else
                sparams.basisVectors(ii,jj) = currentConfig(jj)/2;
                sparams.basisVectors(ii,jj + sparams.numElectrons) = 1;                
            end
        end
    end
         
    % Display all the basis states
    if sparams.verbose
        spinUp = '\x2191';
        spinDown = '\x2193';
        for ii = 1:nStates
%         for ii = 1:1
            
            basisVecsStr = sprintf('State %d: |',ii);
            for jj = 1:sparams.nSingleOrbitals
                basisVecsStr = [basisVecsStr '0,'];
            end
            basisVecsStr = [basisVecsStr(1:end-1), '>'];
            
            % Used for correctly modifying string when we modify the string
            % and need extra characters
%             extraCount = 0;
            for jj = sparams.nSingleOrbitals:-1:1
                ind = find(sparams.basisVectors(ii,1:sparams.numElectrons) == jj);
                if length(ind) == 2
                    basisVecsStr = [basisVecsStr(1:(end-2*jj)) spinUp...
                        spinDown basisVecsStr((end-2*jj+2):end)];
                elseif length(ind) == 1
                    spinState = sparams.basisVectors(ii,sparams.numElectrons+ind);
                    if spinState == 0
                        elecSpin = spinUp;
                    else
                        elecSpin = spinDown;
                    end
                    basisVecsStr = [basisVecsStr(1:(end-2*jj)) elecSpin...
                        basisVecsStr((end-2*jj+2):end)];
                end
            end
            fprintf(1,[basisVecsStr, '\n']);
        end
    end

    % Now we want to truncate the spin subspace if desired
    % First calculate the possible spin subspaces
    possibleSz = -sparams.numElectrons*0.5:1:sparams.numElectrons*0.5;
    if istring(spinSubSystems)
        if strcmpi(spinSubSystems,'all')
            % Do nothing as we want the whole spin subspace
        else
            error('Please specify a valid spin subspace system.\n');
        end
    else
        for ii = 1:length(spinSubSystems)
            currSz = possibleSz(ii);
            for jj = nStates:-1:1
                currSpinConfiguration = sparams.basisVectors(jj,sparams.numElectrons + 1:end);
                for kk = 1:sparams.numElectrons
                    
                end
            end
        end
    end
    
%     T = sparse(zeros(nSOstates^2));
%     Hc = sparse(zeros(nSOstates^2));
    % The second quantization hamiltonian has two terms: T + H_C.  T
    % describes all the single particle energies in the hamiltonian while
    % H_C describes all the exchange interactions.
    
%     % Let's first build the single-particle energy operator
%     for ii = 1:nStates
%         for jj = 1:nStates
%         end
%     end
end

